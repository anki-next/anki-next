use convert_case::{Case, Casing};
use std::{fs, io::Write, path::PathBuf};

use anki_proto_gen::BackendService;

fn short_service_name(name: &str) -> (String, String) {
    let name = name.trim_start_matches("Backend");
    (
        name.to_owned(),
        name.trim_end_matches("Service").to_case(Case::Camel),
    )
}

pub(crate) fn generate(dir: &PathBuf, services: &[BackendService]) {
    let file = dir.join("service.ts");

    let mut contents = vec![];

    //     contents.push(
    //         "/* eslint-disable */
    // // tslint:disable
    // // @ts-nocheck
    // "
    //         .to_owned(),
    //     );

    // imports
    contents.push(
        "
import {IsEqual} from 'type-fest';
"
        .to_owned(),
    );

    for service in services {
        let (name, _) = short_service_name(&service.name);
        contents.push(format!(
            "import {{ {name}Client, Backend{name}Client,I{name}Client, IBackend{name}Client }} from './protobuf/{}';",
            service
                .proto
                .parent_file()
                .name()
                .replace(".proto", ".client.ts")
        ));
    }

    // service map
    contents.push("export const SERVICES = {".to_owned());
    for service in services {
        let (name, camel) = short_service_name(&service.name);
        contents.push(format!(
            "  {camel}: [{Index}, Backend{name}Client, {name}Client],",
            Index = service.index,
        ));
    }
    contents.push(
        "} as const;
export type ServiceMapType = typeof SERVICES;
"
        .to_owned(),
    );

    // method map
    contents.push("export const METHODS = {".to_owned());
    for service in services {
        let (_, camel) = short_service_name(&service.name);
        contents.push(format!(
            "  {camel}: {{ {Methods} }},",
            Methods = service
                .all_methods()
                .map(|method| format!("{}: {}", method.name.to_case(Case::Camel), method.index))
                .collect::<Vec<_>>()
                .join(",")
        ));
    }
    contents.push(
        "} as const;
export type MethodMapType = typeof METHODS;
"
        .to_owned(),
    );

    // ensure types generated by protobuf-ts same with anki_proto_gen::get_services
    contents.push(
        "
type EnsureTrue<T extends true> = T extends true ? true : never;
"
        .to_owned(),
    );

    let unions = services
        .iter()
        .map(|svc| {
            let (name, camel) = short_service_name(&svc.name);
            format!("IsEqual<keyof (IBackend{name}Client&I{name}Client), keyof MethodMapType['{camel}']>")
        })
        .collect::<Vec<_>>()
        .join("&");

    contents.push(format!(
        "export type _EnsureMethodsConsistent = EnsureTrue<{unions}>;",
    ));

    let mut file = fs::File::create(file).unwrap();
    file.write_all(contents.join("\n").as_bytes()).unwrap();
}
